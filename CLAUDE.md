# Project Operating Guide

This template assumes the commands inside `.claude/` drive all serious work. Documentation was intentionally removedâ€”commands and scripts must guide the user end-to-end.

---

## Non-Negotiables
- **Stay inside slash commands.** If the user provides a plain request, reply with the recommended command (usually `/quick`, `/scout_build`, or `/full`) and offer to run it.
- **Keep automation in sync.** Build-style commands must:
  1. Write a session summary to `ai-docs/sessions/`.
  2. Run `npm run vectorize` after writing artifacts.
  3. Call `npm run tasks:session-start` or `npm run plans:*` when prompted so the ledger stays current.
- **Verification clarity.** When a command pauses (plan approval, manual checks, etc.), always print:
  - `ðŸ›‘ Still inside /<command>. Reply 'resume' to continue or 'stop' to exit.`
  - Mention what will happen on resume (e.g., `resume` âžž `/build`).
- **No template references.** Never mention removed folders (`TEMPLATE-DOCS`, `GETTING-STARTED`, etc.). Point users to commands or scripts instead.

---

## Folder Cheat Sheet
- `app-docs/specs/{active,archive,reference}` â€“ Feature knowledge maintained by the user.
- `ai-docs/{plans,builds,sessions}` â€“ Automation outputs. Commands append here automatically.
- `ai-docs/tasks/tasks.json` â€“ Task + token ledger (read/write using `npm run tasks:*`).
- `scripts/` â€“ Node helpers invoked by commands (`vectorize-docs.js`, `manage-knowledge.js`, `manage-tasks.js`).
- `vector-store.json` â€“ Embedding store generated by `npm run vectorize`.

---

## Command Expectations
- `/start` â€“ Initializes feature folder + session log. After running, suggest `/scout`.
- `/scout` â€“ Collects context. On completion, auto-trigger `/verify_scout`. If confidence <70%, offer targeted re-scout. Finish with recommended next command.
- `/plan` â€“ Produces implementation plan. After writing the plan:
  1. Print the save path.
  2. State the verification prompt (`ðŸ›‘ ...`).
  3. Suggest `/build_w_report "<plan path>"` once approved.
- `/build` & `/build_w_report` â€“ Implement plan, run git diff, write session log, `npm run vectorize`, `npm run tasks:session-start`. Always remind the user to run `/test`.
- `/scout_build` â€“ Calls `/scout`, then builds immediately. Still print session log + vectorize instructions and `/test` prompt.
- `/quick` â€“ Lightweight build without plan. Must update session log, run vectorize, and prompt `/test`.
- `/full` â€“ Orchestrates `/scout`, `/plan`, waits for approval, then `/build_w_report`. Surface verification message explicitly before waiting.
- `/test` â€“ Runs suite and tells user whether to deploy (`/deploy_staging`) or fix & rerun.

Every command ends with a **Next Steps** section containing literal commands to copy/paste.

---

## Task & Knowledge Management
- Use `npm run tasks:session-start` at the beginning of each session. It prints the recommended slash command that keeps automation aligned.
- `npm run manage-knowledge -- archive|restore <spec>` moves specs between `app-docs/specs/active` and `archive` (auto-runs `npm run vectorize`).
- `npm run search -- "query"` returns the top 3 semantic matches across indexed docs and sessions.

---

## Handling Plain Prompts
When the user types a regular question instead of a slash command:
1. Respond with the exact slash command that should run next.
2. Ask if you should execute it now.
3. Only proceed once the user confirms; otherwise stay ready.

This guarantees the recommended workflow executes, even when the user forgets.

---

## After Each Build/Test Cycle
1. Confirm git diff summary and files touched.
2. Point to `ai-docs/sessions/<session>.md` so the user can skim what changed.
3. Prompt `/test` âžž `/deploy_staging` chain.
4. If tests fail, guide the user to fix and rerun `/test`.

Stick to these rules and the workflow stays self-healing without extra documentation.
